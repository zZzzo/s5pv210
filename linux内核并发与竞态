                                =====================================================================
                                                        linux内核并发与竞态
                                =====================================================================
								
	阻塞与非阻塞是设备访问的两种方式。驱动程序需要提供阻塞（等待队列，中断）和非阻塞方式（轮询，异步通知）访问设备。在写阻塞与非阻塞的驱动程序时，
经常用到等待队列。在多个执行单元同时发生时，并发的多个执行单元对共享资源的访问导致的竞争状态。
	“内核中提供各种形式的锁，而且加锁的粒度范围也不同，各种锁机制之间的主要区别在于被争用时的行为表现：有的锁被争用时会简单的执行忙等待，有些锁会使当前的人物睡眠直到锁可用为止。”
	1、具体什么时候会产生竞态？
	  1)SMP
	  2)单CPU支持任务中断
	  3)中断和进程之间
	  4)中断和中断之间
	2、解决方法：
	  1)中断屏蔽
			 直接屏蔽中断,这时候所有的东西都抢占不了当前要使用的资源，但是风险太高了,比如连看门狗中断也被屏蔽了...不建议使用.
	  		 操作：
			 	local_irq_disable() 和 local_irq_enable();
	  2)原子操作
	  		 分为位原子操作和整型原子操作
	  3)自旋锁
	  		 自旋，即原地打转，因为最多只有一个持有者，所以在等待一个已经被使用的临界资源时，会不断询问，在这里看自旋锁是否被持有者释放。所以自旋锁不会使进程睡眠，比较耗CPU。
			 操作：
			 	 它被定义在include/linux/spinlock_types.h中。
			 		定义：spinlock_t lock;
					初始化：spin_lock_init(...)
					获取锁
						spin_lock(...)		//如果不成功,则一直自旋等待。
						spin_trylock(...)	//如果不成功,直接返回错误值
					操作临界资	
					释放锁：spin_unlock(...)
			注意:
				1.spin_lock()和spin_unlock()要成对出现,如果两次释放锁,可能导致内核崩溃
				2.自旋锁保护的临界资源要尽量的短(代码段要短)，因为他会不断的耗CPU，所以要尽量减少发生竞态的情况。
				3.“自旋锁可以使用在中断处理函数中(此处不能使用信号量,会导致睡眠),在中断处理程序中使用自旋锁，一定要在获取锁之前，首先禁止本地中断(当前处理器上的中断请求)否则，中断程序会打断正持有锁的内核代码，有可能去争用这个已被持有的自旋锁，会导致双重请求死锁。”
				4.内核提供的请求锁的同时禁止中断的接口：
					spin_lock_irqsave(&lock, flags);
					spin_unlock_irqrestore(&lock, flags);
				 注意这里是保存中断的当前状态，然后去禁止它，所以即使中断本来就禁止，再恢复它的时候也不会被开启。
	  4)信号量
		linux中的信号量是一种睡眠锁，当一个任务要获取一个已经被占用的信号量时，信号量会将其推进一个等待队列，然后让其睡眠，当持有信号量的进程将信号量释放后，处于等待队列中的任务将被唤醒，并获得该信号量。
		 信号量相关结构体：
		 		struct semaphore {
			spinlock_t		lock;
			unsigned int		count;
			struct list_head	wait_list;
		};
		操作方法:
		定义信号量
			struct semaphore sem;
		初始化信号量
			sema_init(*sem,int val);
			init_MUTEX(*sem);		信号量初始化为1
			init_MUTEX_LOCKED(*sem)		初始化为0
			
			DECLARE_MUTEX(name)	定义并初始化为1
		获取信号量(	将sem-1)
			down(...)	//	获取不成功将导致进程睡眠
			down_interruptable(...)		//获取信号量不成功导致进程进入可中断的睡眠
			down_killable(...)		//不成功 导致可killable的睡眠
			down_trylock(...)		//不成功，直接返回错误号
	
		访问临界资源
		
		释放信号量(将sem+1)
			up(...)
-------------------------------------------------------------------
				等待队列(处理阻塞)
-------------------------------------------------------------------	
	操作方式:
		创建一个等待队列头：
			wait_queue_head_t wq;  //等待队列头
		初始化
			init_waitqueue_head(wait_queue_head_t *q);
		操作
			wait_event(wait_queue_head_t wq, condition)
				wq: 等待队列
				condition://条件 逻辑表达式 ,为1时代码往下执行,为 0 就挂起  
			wake_up(wait_queue_head_t *q)
	
	另外一种：(可被中断打断)
	wait_event_interruptible(...)	//阻塞
	wake_up_interruptible(...)		//唤醒			 
















