===========================================
一、模块编译
===========================================
		以helloworld.c为例，要将helloworld编译进内核，意思就是要把helloworld
	变成zImage的一部分。有两种方式将它添加到zImage中，一种是必须编译进内核，
	一种是编译成内核模块，再动态添加到内核中。下面分析：
	1、在linux目录下的每个文件夹中，都有.config kconfig Makefile文件
	其中.config :在进行内核配置的时候，经过配置后生成的内核编译参考文件。
		kconfig：make-meunconfig产生菜单的要素。
		Makefile：决定当前目录下的文件是否编译进内核。
				obj-y:必须编译进内核
				obj-m:编译成内核模块
	2、obj-y:
		方法一：直接在Makefile中配置
		在当前文件夹(例如是drivers/char(字符设备))，创建一个helloworld.c文件
	然后在Makefile中添加 "obj-y	 +=helloworld.o"(这里Makefile自己会去找到.c文件)
		方法二：配置Kconfig文件
		类似这样：
		---------------------------------------------------------------
		config SGI_TIOCX
		bool "SGI TIO CX driver support"
		depends on (IA64_SGI_SN2 || IA64_GENERIC)
		help
			If you have an SGI Altix and you have fpga devices attached
			to your TIO, say Y here, otherwise say N.
		----------------------------------------------------------------
		然后可以在menuconfig界面选择 -y 还是 -m
		
	3、obj-m 编译成内核模块：
		方法一：(源码放在内核源码目录下drivers/char下)(不太好)
			(总结:这里不需要自己写Makefile，但是生成的中间文件都在内核源码里了)
		在drivers/char/Makefile中，(helloworld.c在这个目录下)
		"obj-m	+=helloworld.o"
		通过命令make module	=>生成helloworld.ko模块文件
		将它copy到NFS的目录下。在目标板加载insmod helloworld.ko
		或卸载rmmod helloworld(这里不需要.ko)
		方法二：(源码不放在内核源码目录下)
			(总结:这里要自己写一个Makefile)
		一样在Makefile中添加"obj-m	+=helloworld.o"
		通过命令 make -C {内核源码根目录} M=$(pwd) modules
		=> -C {内核源码根目录} :指定内核源码根目录(不同的内核版本会有不同的方法，所以指定目录在特定的版本下编译)
		=> M=$(pwd) 指定Makefile要做的动作(当前目录下的Makefile)
	---------------------------------------------------------------------------
	ifeq ($(KERNELRELEASE),)
	KERNELDIR=/home/tarena/fs210/kernel/org/linux-3.0.8
	CUR_DIR:=$(shell pwd)

	modules:
        $(MAKE) -C $(KERNELDIR) M=$(CUR_DIR) modules
	modules_install:
			$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
	clean:
        rm -rf *.o *~core *.ko *.mod.c .tmp_versions Module.symvers modules.order
	else
		obj-m:=hello_driver.o
	endif
	----------------------------------------------------------------------------
	__init 定义的函数放到了.init.text段		
	__exit 定义的函数放到了.exit.text段
	特点:被这两个关键字修饰的函数，只要被指令一次后就不会再执行了
	程序被执行的时候在内存中，被执行一次后就不再执行，那么不可能让它一直占用内存
	内核有个机制会自动把__init和__exit修饰的函数的内存释放了。
	
	被module_init修饰的函数在加载模块是会被调用到
	被module_exit修饰的函数在写在模块是会被调用到
插：要写上MODULE_LICENSE("GPL v2") 防止污染
=============================================
二、内核导出符号
=============================================
	EXPORT_SYMBOL(xx函数名);
	这样就能被外部文件就能调用了。
	在Makefile中要将两个模块写在同一行
	注意的点：声明的局部变量一定要放在可执行代码前。
=============================================
三、模块参数	
=============================================
	怎么用：必须是全局变量，然后要用module_param(name,type,purview);声明一下。
	可以用 MODULE_PARM_DESC(name,description);	对模块参数描述。 

	类型：byte, short, ushort,int, uint, long, ulong, charp, bool, invbool； 
	
	将内核模块xxx.c文件中申请的全局变量声明为模块参数
	内核的一种机制：可以在用户空间下修改内核模块中的全局变量的值。
	意思就是可以在目标板上查看，修改全局变量的值，insmod xx.ko xx=??...
	这些值放在 /sys/module/modparam/parameters/中 
	作用：
=============================================	
四、内存管理
=============================================
	先分清几种地址的区别：
	1.逻辑地址：汇编文件中使用的偏移地址
	2.虚拟地址(线性地址):
		UC编程时使用的地址，每个进程都有0~4G独立空间(其实是3G,3G~4G为内核空间)
		为什么是4G空间:CPU的寻址范围是2^32 = 4G
	3.物理地址：出现在物理总线上的地址
	三者的关系：逻辑地址经过段式管理单元变成虚拟地址
				再经过页式管理单元变成物理地址
		(1)段式管理单元：
			①从16位CPU说起，内部地址总线是20bits，寻址能力 1M
		内部寄存器时16bits，(寄存器只能表示16位数据，而要送到地址总线上要20位数据)
		引出段基址寄存器 和 段内偏移寄存器
		段基址寄存器(CS DS SS ES)
		段内偏移寄存器(IP SP BX)
		虚拟地址 = 段基址 <<4 +段内偏移 =>变成20bits地址
			②再看32位CPU，内部地址总线32位，内部寄存器32位,这样是不存在矛盾的，但是
			为了系统的兼容性，也引用了段式管理机制。-->实模式和保护模式
			PC机刚开始上电的时候是实模式，寻址能力比较弱(1M),类似于16位CPU的
			段式管理单元，但是绝大部分时间工作于保护模式(它将32位地址分成两部分，
			前一部分指向内存的另一个位置，这时候这个位置存放的两项关键的内容base和limit
			base就是段基址，真正的偏移值是第二部分，将段基址加上第二部分的地址，就得到
			逻辑地址。得到的逻辑地址要判断有没有权限能够访问，limit就是判断权限的字段。
			所以叫做保护模式。)
			
		(2)页式管理单元：     
	4.在linux中的情况：
		(1)linux的管理机制：
		linux内核中没有(有限的)使用了段式管理机制，充分使用了页式管理机制。
		linux始终认为基地址寄存器值为0，逻辑地址 = 虚拟地址
		充分使用了页式管理机制：四级页表。
		(2)怎么管理：
		linux内存管理的最小单元：页(没有按比特按字节去管理)通常32位CPU一页为4k
		内核中管理内存的数据结构:struct page 每页都生成一个page，1G内存就有(1G/4k)个page
	5.内核中内存的分配：
		申请用户空间：malloc/free  new/delete  valloc
		申请内核空间：kmalloc/kfree(申请到的物理空间是连续的)
					  vmalloc/vfree(申请到的物理空间可能不连续) 
					  __get_free_pages/free_pages(获取空闲页)
		申请到的地址都在3G~4G范围 （3G分界点：0xc0000000）
	--------------------------------------------------------------
	关于flags：
		GFP_KERNEL:分配内存过程中可能导致睡眠
		GFP_ATOMIC:分配过程中不会导致睡眠。(不满足则直接返回一个错误值)
			会导致睡眠的情况：当前的内存空间不够你申请的大小时，会睡眠等待到有足够的大小。
		GFP_DMA:申请到的内存通常情况下位于0~16M之间
	关于返回错误值：
		类似 IS_ERR(kernelkmalloc)
				
	--------------------------------------------------------------			
=============================================
五、内核链表(include/linux/list.h)
=============================================
		INIT_LIST_HEAD
		list_add
		list_del
		list_for_each
		list_entry
=============================================
六、内核定时器
=============================================
	(后面按键去抖动会用到)
	时钟中断：
		HZ:决定了时钟中断发生的频率
		tick:发生时钟中断的时间间隔 tick = 1/HZ
		jiffies：(unsigned long类型的数据) 核心变数(自开机以来，经过多少个tick，没发生一次硬件定时器中断，jiffies变数会加1)
		init_timer
		add_timer
		mod_timer
	有个重要的struct
		struct timer_list
		{
			...
			unsigned long expires;	//超时时间
			void (*function)(unsigned long);	//处理函数
			unsigned long data;		//被处理函数调用的参数
			...
		}
	实现  ：1.设置expires = jiffies + HZ *定时间隔;	
				//核心变数 + 时间间隔,意思就是在加载模块那个时刻过后的n秒
			2.设置function = 处理函数;
			3.设置data = 传递的参数;
			4.实现一个处理函数void handler(unsigned long)
=============================================
七、系统调用
=============================================		
首先，驱动程序是为应用程序提供服务的，但是驱动程序是在内核态执行，
那么应用程序要就要通过系统调用来执行驱动程序(调用)。

明确一点：用户态的程序一般是不能访问内核态的资源，
只有通过中断或者系统调用才能从用户态进入内核态。
在3.0.8内核中 系统调用的个数是375个。 Unistd.h文件中定义

系统调用的原理：
	应用程序调用syscall(number,....)，即首先使用适当的值number填充寄存器，然后调用一个特殊的指令，跳转到内核某个位置，
	内核根据应用程序所填充的固定的值来找到相应的函数执行。
	
	适当的值： arch/arm/asm/Unistd.h下的375个系统调用都有对应的值，
	特殊的指令：arm ->SWI(软中断)
		跳转到entry-common.S	->vector_swi
		在vector_swi会使用sys_call_table(这个表在calls.S)
-----------------------------------------------------------------------
实现一个自己定义的系统调用：	
	1.添加新的内核函数：
		在arch/arm/kernel/sys_arm.c下
			asmlinkage int sys_add(int x, int y)
			{
				printk("enter sys_add!\n");
				return x + y;
			}
		asmlinkage表示不使用寄存器
	2.更新头文件：
		在arch/arm/niclude/asm/unistd.h下：
		#define __NR_add	(__NR_SYSCALL_BASE+376)
	3.更新系统调用表(calls.S)
		CALL(sys_add)
	4.make
	完成
-----------------------------------------------------------------------
=============================================
首先，按照硬件特性分类
	字符设备  (顺序读写，不带字符)
	块设备	  (读写顺序不固定，带有读写缓冲)
	网络设备  (之所以单独作为一类，是因为破坏了linux下一切皆文件的规则)
八、字符设备框架
=============================================
首先，硬件上有一个字符设备，内核中就有一个cdev结构体与之对应(面向对象的思想)
	体现在下面这个结构体;操作这个设备的相关函数的集合体现在第二个结构体
	第一个重要的结构体	Cdev.h
	struct cdev
	{
		dev_t dev;	//设备号
		const struct file_operations *ops;	//一些操作的函数集合
	}
-------------------------------------------------------------------
	1.设备号(32bits) = 主设备号(高12bits) + 次设备号(20bits)：
-------------------------------------------------------------------
		每个cdev都有一个设备号,主设备号：代表一类设备，次设备号:区分该设备中的不同个体
	主设备号的选取：
		-->静态分配：
			1.先看现在内核中哪些主设备号没有被使用，选择一个使用
				cat	/proc/device
				Documentation/device.txt
			2.获取设备号dev：
				register_chrdev_region(from, count, name)
			
	插：内核中xxx_t的数据类型其实就是是通过typedef定义出来的，为了内核的移植性
		-->动态分配	
			1.alloc_chrdev_region(*dev, baseminor, count, name)
-------------------------------------------------------------------
	2.cdev 的操作函数
-------------------------------------------------------------------
		cdev_init(...)	//初始化cdev
		cdev_add(...)	//向内核注册cdev
		cdev_del(...)
	第二个重要的结构体	Fs.h下
	struct file_operations 	
	{
		...
	}
	写驱动就是写这个结构体下的函数的实现。但是不必全都实现，只要实现需要的部分。
	
	手动创建设备节点文件 mknod /dev/cdd c 254 0	(这里c表示字符设备)
		
	****************************************************************
	过程分析：
		insmod cdd.ko
		mknod /dev/cdd c 254 0
		./test
		open("/dev/cdd",)
			[open这个设备的时候，这个设备有这样的属性c 254 0，传到内核syscall_open去]
			[c 254 0 内核通过这个信息能去找到内核中唯一对应的cdev，
			找到这个cdev对应的操作函数集合，然后就能找到对应的cdev_open函数
			]
		那么现在想，/dev/cdd起到什么作用?
			在用户空间使用open，其实就是给内核syscall_open传递一个参数c 254 0
			通过这3个参数，就能找到内存中对应的cdev(因为前面说过每个设备有自己的cdev结构，有点面向对象的思想在这)
			找到cdev，其实就是就找硬件上的设备。
		------------------------------------------------------
		syscall_open
			->do_sys_open
				->do_filp_open
					->do_last
						->nameidata_to_filp
							->__dentry_open
								->chrdev_open(打开字符设备文件时，这个函数肯定会被调用)
									->filp->f_op->open(cdd_open)(最后这里调用到我们写的cdd_open)
	****************************************************************
	插：上面提到的流程中，先是加载内核模块，手动创建设备结点，运行测试程序。
		手动创建设备结点：mknod命令
		自动创建设备结点：1.创建设备类	2.创建设备
			在/dev/cdd0是用户态的程序创建的设备结点文件，并不是内核创建的。
			(
				1.udev(PC平台下)，根据/sys/的变化，动态在/dev创建设备节点文件。
				具体实现：udev，是个后台守护进程，接收uevent事件，device_create()
				会发出该事件，udev会根据事件信息创建/dev/cdd0
			
				2.mdev(嵌入式平台下),device_create()会直接使用/sbin/mdev程序
				来创建设备节点文件。
			)
		插：/proc -->procfs 导出内核运行状态信息
			/sys  -->sysfs	终点在于导出内核中所有硬件设备
-------------------------------------------------------------------
	3.支持多设备
-------------------------------------------------------------------	
	前面创建了1个设备文件
	(1.注册设备号(静态/动态),
	 2.每个设备对应自己的cdev,所以初始化cdev,当然初始化时候参数是cdev结构体对象
	 和操作函数集合fops，所以这里还要实现一下fops里需要的函数;然后添加到内核。
	 3.创建设备节点文件(手动/自动)
		手动:mknod命令 mknod /dev/cdd c 设备号 几个
		自动:分为2步,一是注册设备类，二是注册设备
			1.注册设备类class_create,它会在/sys/class/下创建这个设备类的文件夹给下一步用
			2.注册设备device_create,在上一步的/sys/class/cdd_class/下创建设备cdd0
				并且在/dev/创建一个cdd0
	)
	现在看怎么在一个.c文件中编写创建多个设备文件
	一样的注册设备号(静态/动态),然后先是创建设备类(我只要一个设备类,下面多个设备)
	然后在一个for循环里(循环次数看要创建几个设备)初始化cdev,添加cdev到内核;创建设备节点
-------------------------------------------------------------------
	4.确定操作的是哪个设备
-------------------------------------------------------------------		
	首先，怎么区别不同的设备,例如在调用cdd_open时，怎么知道是cdd1还是cdd2...
	在用户空间中调用open(""/dev/cddx"");
	内核态中的cdd_open()怎么知道是调用那个设备
	
	内核中每个文件对应一个inode节点，保存了这个文件所有信息。
	其中,dev_t(设备号)	struct cdev(cdev_add向内核添加的那个cdev设备节点)
	打开这个文件后，会被加载到内存中,之后要调用就很快了。
	struct inode{
		...
		dev_t		//记录设备号
		struct cdev	//指向了cdev_add时添加的cdev
	}
	在调用cdd_open时，从inode节点取出保存的信息。
	container_of(inode的信息,要放在什么结构体,放在结构体中的哪个成员);
	
	第二点，在调用read/write...时，怎么知道操作的是哪个设备?
	首先,在read中是区分不了的,它的参数固定写死的，并没有inode节点。
	这里,在open函数调用时,
		f0 = open("/dev/cdd0",)-->内核生成一个 struct file
		f1 = open("/dev/cdd1",)-->内核生成一个 struct file
		
		调用read(fd0,)
				cdd_read(struct file *filp,)
			read(fd1,)
				cdd_read(struct file *filp,)
	这里虽然都是调用cdd_read，传递的filp是不一样的。也就是说,在open调用时，
	会把对应设备的信息保存在struct file里面,给read/write...使用。
	struct file{
		...
		void*private_data;
		...
	}
	
	read函数第一个参数struct file*和open函数第二个参数struct file*一样。
	发现在open函数调用时，会将设备信息放在file结构体中，然后在read函数时，
	会去读取file结构体的信息，得到对应的设备信息。
	
	所以说，open函数是通过inode去区别不同的设备文件，并将信息保存在file结构体中,
	read是通过file结构体找到的唯一对应的设备。
-------------------------------------------------------------------
	5.内核空间和用户空间数据的交互问题
-------------------------------------------------------------------		
	内核态数据向用户态拷贝	--->copy_to_user(...)
	用户态数据向内核中拷贝	--->copy_from_user(...)
-------------------------------------------------------------------
	6.控制GPIO
-------------------------------------------------------------------	
(一)直接操作相应寄存器
(二)通过内核提供的GPIO操作函数.	
	例:要控制led灯的亮灭.有两种实现方法:
	(1)创建两个设备节点文件
		/dev/led0	 /dev/led1
		cdev0		 cdev1
		fd0 = open("/dev/led0",O_RDWR);
		第一盏灯:
		ioctl(fd,cmd,data);	第三个参数不用
			ioctl(fd0,1,0);	第二个参数 1亮/0灭
		第二盏灯:
		fd1 = open("/dev/led1",O_RDWR);
		ioctl(fd,cmd,data);	第三个参数不用
			ioctl(fd0,1,0);	第二个参数 1亮/0灭
	(2)创建一个设备节点
		fd = open("/dev/led",O_RDWR);
		ioctl(fd, cmd, data);
		第一盏灯:
			ioctl(fd, 1, 0);
		第二盏灯:
			ioctl(fd, 1, 1);
-------------------------------------------------------------------
	7.cdev起到什么作用
-------------------------------------------------------------------	
	用户空间				内核空间
	open				 	xxx_open
			之间的桥梁
-------------------------------------------------------------------
	8.驱动程序的调试
-------------------------------------------------------------------		
	printk
	oops
	kgdb
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		